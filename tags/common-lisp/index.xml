<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Common Lisp on Raj Patil</title><link>https://rajp152k.github.io/tags/common-lisp/</link><description>Recent content in Common Lisp on Raj Patil</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 29 Aug 2023 11:09:43 +0530</lastBuildDate><atom:link href="https://rajp152k.github.io/tags/common-lisp/index.xml" rel="self" type="application/rss+xml"/><item><title>Common Lisp : The Series - 0.1 : Representing Programs</title><link>https://rajp152k.github.io/post/clts/clts-0.1/</link><pubDate>Tue, 29 Aug 2023 11:09:43 +0530</pubDate><guid>https://rajp152k.github.io/post/clts/clts-0.1/</guid><description>What makes lisp so unique is the way its code is structured - you definitely can&amp;rsquo;t miss all those parentheses. In this section of the series, I discuss the cause for such a representation and how that makes lisp unique in terms of how it views its code as data as code (aka homo-iconicity).
Further reading Python disassembler Homoiconity Byte Code S-expressions Common Operator Notation Abstract Syntax Tree The Blub Paradox Call to collaborate If you&amp;rsquo;re someone who shares the dream of making lisp popular and mainstream so that we can use it for our jobs and don&amp;rsquo;t have to switch to blubs to make a living (without denting its charm of course) , consider contributing to the notes and hit me up via mail or any of the other media I&amp;rsquo;m present on.</description></item><item><title>Common Lisp : The Series - 0 : Introduction</title><link>https://rajp152k.github.io/post/clts/clts-0/</link><pubDate>Mon, 21 Aug 2023 12:03:07 +0530</pubDate><guid>https://rajp152k.github.io/post/clts/clts-0/</guid><description>This is the first in a series of blog posts that follow the educational common lisp series on my youtube channel as an auxilliary.
I&amp;rsquo;ll be summarizing the videos in these blogs and be using these to point to references and additional resources that further elaborate the matter.
This post is about why you should consider learning common lisp and how I intend to execute the plan of building an end to end resource index while simultaneously being able to learn more about the language myself.</description></item><item><title>Common Lisp - A Gentle Introduction to Symbolic Computation</title><link>https://rajp152k.github.io/post/cl-aitsc/</link><pubDate>Wed, 16 Aug 2023 17:51:13 +0530</pubDate><guid>https://rajp152k.github.io/post/cl-aitsc/</guid><description>Given I&amp;rsquo;ve passed through SICP once, quickly grasping common lisp to build stuff and explore the traditional and industrial aspects of lisp (I know clojure exists but traditional&amp;hellip;) was my next objective: with decent speed and only solving the somewhat involved exercises, it took me two weeks to complete this book.
The exercises aren&amp;rsquo;t meant to be a challenge but to adapt to the environment and the topics introduced. The book does not explore concepts with depth (CLOS, macros, etc&amp;hellip;) but that shouldn&amp;rsquo;t be the objective of an introduction anyway.</description></item></channel></rss>